# vim: ft=python
import builtins
import json
from os import path
from pathlib import Path
from pprint import pprint

# import pdbpp
from xonsh.prompt import vc
from xonsh.events import events
from prompt_toolkit.keys import Keys
from prompt_toolkit.filters import (
    Condition,
    # EmacsInsertMode,
    ViInsertMode,
)
# from xonsh.prompt.gitstatus import GitStatus, get_gitstatus_info
# from prompt_toolkit.key_binding import vi_state
# from prompt_toolkit.keys import Keys
from prompt_toolkit import filters

# xontribs
# TODO: figure out how to install these correctly..
# - xontrib load prompt_ret_code pacman_tabcomplete vox_tabcomplete vox
# - xontrib load xxh
xontrib load vox

# UX + style customizations
$MULTILINE_PROMPT = '{GREEN}...:'  # copy ipython
$XONSH_SHOW_TRACEBACK = True
$XONSH_STORE_STDOUT = True
$XONSH_COLOR_STYLE = 'default'

# REPL conf
$VI_MODE = True
$SHELL_TYPE = 'prompt_toolkit'
$SHELL = 'xonsh'
$AUTO_PUSHD = True
$UPDATE_PROMPT_ON_KEYPRESS = False

$SYSTEMD_EDITOR='nvim'


# add home bin to the path
$PATH.append(path.join(
    $HOME,
    'etc',
    'bin',
))


def _gh_edit_issue_body(
    args: list[str],
    std: str,

) -> None:
    '''
    Edit the issue body pulled from gh given the number is the `args[1]`
    value, open it in nvim for editing, then write the file on exit
    and push the final body contents back to github.

    Originally written to proces ``gh issue view <#> --json body`` calls
    and write back to github something like,

    ```xonsh
        get_body($(gh issue view 461 --json body)) '$arg1.md'
        && nvim --cmd ':set ft=markdown' '$arg1.md' &&
        gh issue edit $arg1 --body-file $arg1.md
    ```

    '''
    provider: str = 'Github'
    issue_num: str = args[0]
    try:
        int(issue_num)
    except ValueError:

        # presume user wants to create a new issue if no int
        # value was passed to edit.
        # TODO: obvs we need to considering non-int issues on other
        # platforms eventually, etc..etc.
        # title: str = str(issue_num)
        gh issue create
        return

    try:
        resp_str: str = $(gh issue view @(issue_num) --json body)
        body = json.loads(resp_str)['body']
    except json.decoder.JSONDecodeError:
        print(f'No issue for {issue_num} exists!')
        return

    fn = f'{issue_num}.markdown'

    # create sub-dir in any detected repo and org files there.
    if vc.current_branch():
        local_issue_dir = Path('.gh/')
        local_issue_dir.mkdir(exist_ok=True)
    else:
        local_issue_dir = Path('./')

    # TODO: do diff with any existing (local cached) file
    # and only push changes if any measured.

    # write body contents to local file with issue number for name.
    local_file = local_issue_dir / fn
    fn_str = f'{str(local_file)}'

    if not local_file.exists():
        with local_file.open(mode='w') as mdfile:
            mdfile.write(body)

    # check if local matches GH
    with local_file.open(mode='r') as mdfile:
        orig = mdfile.read()
        if body != orig:
            print(f'local file {fn_str} and GH version are diff!')
            orig = body

    with local_file.open(mode='w') as mdfile:
        mdfile.write(body)

    # open issue body conents, now written to a file with
    # a name of the number of the issue, with editor.
    nvim --cmd ':set ft=markdown' @(fn_str)

    with local_file.open(mode='r') as mdfile:
        new = mdfile.read()
        if new == body:
            print(
                f'Nothing changed in {fn_str}\n'
                f' => skipping remote server sync @ {provider}!'
            )
            return

    # push file contents back to github.
    print(f'Syncing update for {issue_num} with GH')
    gh issue edit @(issue_num) --body-file @(fn)


def _urls_to_lj(
    args: list[str],
    std: str,

) -> None:
    '''
    Take the copied urls from the ``xclip -selection clipboard -o``
    buffer, parse them to entries and dump into TOML format for storage
    in a linkjournal file.

    '''
    urls_str: str = $(xclip -selection 'clipboard' -o)
    urls: list[str] = urls_str.split()
    pprint(urls)

    # TODO: write a sane tomli-like writer that renders human readable
    # arrays of tables, since we need it here as well as in
    # piker.accounting..
    # breakpoint()


aliases.update({
    'grep': 'grep -n --color=auto',
    'ip': 'ip -c',
    'la': "ls -a",
    'less': 'less -R',
    'll': "ls -l",
    'lla': "ls -la",
    'ls': "ls -FNh --tabsize=0 --color=auto --show-control-chars --group-directories-first",
    'wanip': 'dig +short myip.opendns.com @resolver1.opendns.com',
    'vim': 'nvim',
    'smbz': "espeak-ng 'meh lahh pelaas'",

    # custom ad-hoc thingers..
    'gish': _gh_edit_issue_body,
    'pikerup': 'cd $HOME/repos/piker; vox activate piker310',
    'urldump': _urls_to_lj,

})
# faster completion to "ipy<tab>thon"
aliases.pop('ipynb')

# Coloured man page support
# using 'less' env vars (format is '\E[<brightness>;<colour>m')
# $LESS_TERMCAP_mb = "\033[01;31m"     # begin blinking
# $LESS_TERMCAP_md = "\033[01;31m"     # begin bold
# $LESS_TERMCAP_me = "\033[0m"         # end mode
# $LESS_TERMCAP_so = "\033[01;44;36m"  # begin standout-mode (bottom of screen)
# $LESS_TERMCAP_se = "\033[0m"         # end standout-mode
# $LESS_TERMCAP_us = "\033[00;36m"     # begin underline
# $LESS_TERMCAP_ue = "\033[0m"         # end underline


# def prompt():
#     """Auto update the prompt and cursor colour.
#     """
#     # import pdb; pdb.set_trace()
#     cli = builtins.__xonsh_shell__.shell.prompter.cli
#     if cli:
#         mode = cli.vi_state.input_mode
#         # print("MODE {}".format(mode))
#         if mode == vi_state.InputMode.INSERT:
#             print('\033]12;gray\007')
#             # print("INSERTING")
#             # printf '\033]12;gray\007'
#         else:
#             print('\033]12;red\007')
#             # print("NOT INSERT")
#             # printf '\033]12;red\007'

#     return '\n' + '{env_name:{}}' + ' {GREEN}>>> '


# $PROMPT = prompt
$PROMPT = '\n' + '{env_name:{}}' + ' {GREEN}>>>{DEFAULT} '
# $PROMPT = '{env_name:{}}' + ' {GREEN}>>> '

# gray cursor
# print('\033]12;gray\007')

def maybe_show_vc() -> str:
    '''
    Version control display helper that only shows the branch
    when a vcs is detected.

    '''
    branch = vc.current_branch()
    if not branch:
        return ''

    # dirty = vc.git_dirty_working_directory()
    # ops = gitstatus.get_operations()
    # $PROMPT_FIELDS

    return f'git:{branch}'


$PROMPT_FIELDS['maybe_show_vc'] = maybe_show_vc
# $PROMPT_FIELDS['branch_color'] = lambda: (
#     '{RED}' if vc.git_dirty_working_directory() else '{RESET}'
# )

$TITLE = '{current_job:{} | }{user}@{hostname}: {cwd} {maybe_show_vc}'

# $RIGHT_PROMPT = rprompt
# $BOTTOM_TOOLBAR = rprompt

# namespace bookkeeping
_new = set()


def ctxdiff(
    now,
    start,
    remove,

) -> None:
    new = now - start - remove
    return {k: now[k] for k in new}

    diff = ctxdiff(
        __xonsh__.ctx,
        __xonsh__.ctx['_startctx'],
        {'_startctx', '__name__'},
    )
    _new.update(diff.keys())
    for k, v in diff.items():
        print('{} {}: {}'.format(type(v), k, v))


def clear(args, stdin=None):
    global _new
    for k in _new:
        __xonsh_ctx__.pop(k)
    _new = set()


aliases['ns'] = ctxdiff
aliases['cns'] = clear
_startctx  = __xonsh__.ctx.copy()


# UX related custom key bindings
@events.on_ptk_create
def custom_keybindings(
    bindings,
    **kw
):
    @bindings.add(Keys.ControlSpace)
    def fill_suggestion(event):
        '''
        Allow ctl-space to trigger auto-suggestion like
        c-e and c-f does; except easier to type quick when
        already typing commands with spaces.


        '''
        suggestion = event.current_buffer.suggestion
        if suggestion:
            event.current_buffer.insert_text(suggestion.text)


# @events.on_ptk_create
    # # @handler(Keys.Escape, filter=filters.app.vi_insert_mode)
    # @handler(Keys.Escape, filter=filters.ViInsertMode())
    # # @handler(Keys.Any, filter=filters.Vi())
    # def duhh(event):
    #     """Allow ctl-space to trigger auto-suggestion like -> would.
    #     """
    #     event.cli.output.write_raw('\x1b]12;{}\x07'.format('red'))
    #     event.cli.output.write_raw('\x1b]12;{}\x07'.format('red'))

    #     # mode = event.cli.vi_state.input_mode
    #     # buffer = event.cli.current_buffer
    #     # import pdb; pdb.set_trace()
    #     # # print("MODE {}".format(mode))
    #     # if mode == vi_state.InputMode.INSERT:
    #     #     # print("INSERTING")
    #     #     print('\033]12;gray\007')
    #     #     # printf '\033]12;gray\007'
    #     # else:
    #     # elif mode == vi_state.InputMode.EDIT:
    #     # print('\033]12;red\007')
    #         # print("NOT INSERT")
    #         # printf '\033]12;red\007'

    #     # event.cli.renderer.erase()

    #     # print("event")
    #     # print('\033]12;red\007')
    #     # print('\033]12;gray\007')
    #     # event.cli.editting_mode == 
    #     # if suggestion:
    #     # event.current_buffer.insert_text('\033]12;red\007')

    # @handler('a', 'i', filter=filters.ViNavigationMode())
    # # @handler(Keys.Any, filter=filters.Vi())
    # def yup(event):
    #     """Allow ctl-space to trigger auto-suggestion like -> would.
    #     """
    #     event.cli.output.write_raw('\x1b]12;{}\x07'.format('grey'))

    # # import pdb; pdb.set_trace()
