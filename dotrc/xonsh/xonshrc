# vim: ft=xonsh
import builtins
import json
import site
import sys
from os import path
from pathlib import Path
from pprint import pprint

# import pdbp
from xonsh.prompt import vc
from xonsh.events import events
from xonsh import xontribs
from xonsh.procs.pipelines import CommandPipeline
from prompt_toolkit.keys import Keys
from prompt_toolkit.filters import (
    Condition,
    ViInsertMode,
)
# from xonsh.prompt.gitstatus import GitStatus, get_gitstatus_info
# from prompt_toolkit.key_binding import vi_state
# from prompt_toolkit.keys import Keys
from prompt_toolkit import filters

# UX + style customizations
$MULTILINE_PROMPT = '{GREEN}...:'  # copy ipython
$XONSH_SHOW_TRACEBACK = True
$XONSH_STORE_STDOUT = True
$XONSH_COLOR_STYLE = 'default'
$XONSH_DEBUG = 0

# REPL conf
$VI_MODE = True
$SHELL_TYPE = 'prompt_toolkit'
$SHELL = 'xonsh'
$AUTO_PUSHD = True
$UPDATE_PROMPT_ON_KEYPRESS = False

# $EDITOR='hx'
# $VISUAL='hx'
# $SYSTEMD_EDITOR='hx'
# ------ - ------
$EDITOR='nvim'
$VISUAL='nvim'
$SYSTEMD_EDITOR='nvim'
# ------ - ------
$BROWSER='firefox'
$PAGER='less'
$TERMINAL='alacritty'


_xenv = __xonsh__.env

# hackery for setting up a user-local xonsh env under `.local/
# https://xon.sh/xonshrc.html?highlight=nix#use-the-nix-package-manager-with-xonsh
nixprof: str = f"{$HOME}/.nix-profile"
nixprofpath: Path = Path(nixprof)
is_prolly_nix: bool = path.exists(nixprof)
if (
    is_prolly_nix
    # and not _xenv.get("NIX_PATH")
):
    # $NIX_REMOTE="daemon"
    # $NIX_USER_PROFILE_DIR="/nix/var/nix/profiles/per-user/" + $USER
    # $NIX_PROFILES="/nix/var/nix/profiles/default " + $HOME + "/.nix-profile"
    # $NIX_SSL_CERT_FILE="/etc/ssl/certs/ca-certificates.crt"
    # $NIX_PATH="nixpkgs=/nix/var/nix/profiles/per-user/root/channels/nixpkgs:/nix/var/nix/profiles/per-user/root/channels"
    # $PATH += [f"{$HOME}/.nix-profile/bin", "/nix/var/nix/profiles/default/bin"]
    print('This is prolly a nix install B)')
# if path.exists(nixprof):

    # bash completions path:
    # https://xon.sh/envvars.html#bash-completions
    # on nix this needs to be looked up in the user profile paths
    $BASH_COMPLETIONS=str(nixprofpath / 'share/bash-completion/bash_completion')

    # TODO: look up this path dynamically..
    # use the config from this dotrc repo B)
    $NIXOS_CONFIG = f'{$HOME}/repos/dotrc/dotrc/nixos/configuration.nix'




# try to load xontribs
# TODO: figure out how to install these correctly..
# - xontrib load prompt_ret_code pacman_tabcomplete vox_tabcomplete vox
# - xontrib load xxh
res: CommandPipeline = !(xontrib load vox)
if res.returncode == 0:
    xontrib load gish lnstore
    xontribs.auto_load_xontribs_from_entrypoints(verbose=True)


def add_site_path(path: str = p"~/.local/") -> None:
    '''
    Hack from xonsh docs for nix:
    https://xon.sh/xonshrc.html?highlight=nix#use-the-nix-package-manager-with-xonsh

    '''
    path = Path(path)
    if 'lib' not in str(path):
        path = path / 'lib'

    paths: list[str] = []
    for p in map(
        lambda s: str(s.resolve()),
        path.glob("python*/site-packages")
    ):
        print(f'- scanning path: {p}')
        if p not in sys.path:
            paths.append(p)
            site.addsitedir(p)

    print(f'Hacking in to $PYTHONPATH:\n{paths}\n')


def pyup(
    args: tuple,
    std: str,

    *,
    cd_to_repo: bool = False,

) -> None:
    '''
    Bring up an embedded virtual env using one of:
      - std ``vox`` (since you're on a classic distro) or,
      - ``nix develop`` from flake.nix using `poetry2nix`
        and an embedded ``poetry`` virtual env
        that runs an embedded ``xonsh`` in that env.

    Special heed is made to hack the python path (which is particularly
    handy on nixos where normally each user profile is already totally
    isolated and libraries linked per flake.nix).

    '''
    dst_env: str = args[0]

    src_env_path_str: str | None = _xenv.get('VIRTUAL_ENV')
    if src_env_path_str:
        src_path: Path = Path(src_env_path_str)
        src_env: str = src_path.parts[-1]

        # noop if this env is already activated
        if src_env == dst_env:
            print(f'{dst_env} is already active!?')
            return

        if (
            src_path
            and src_env != dst_env
        ):
            # TODO: use api for this:
            # https://xon.sh/python_virtual_environments.html
            vox deactivate

    elif nixprofpath.is_dir():
        repo_dir: Path = Path.home()/'repos'/dst_env
        cd @(str(repo_dir))

        devfile: Path = repo_dir / '.p2nixdev'
        if devfile.is_file():
            nix develop @(str(devfile))
        else:
            nix develop --profile '.p2nixdev'

    # exit any currently activated vox env then enter the desired vox
    # env and hack the path..
    # vox enter @(dst_env)
    # add_site_path(path=_xenv.get('VIRTUAL_ENV'))

    # TODO: autoload any environment detected xontribs B)
    # see the vox-api xontrib and xonsh hooks:
    # - https://github.com/xonsh/xontrib-vox#voxapi
    # - https://github.com/xonsh/xonsh/blob/ae6b34ba2f62266ca68536484f64cc9a37cf9d1b/xonsh/base_shell.py#L379
    # - https://xon.sh/python_virtual_environments.html#automatically-switching-environments

    # NOTE: currently solution is that they're autoloaded as per using
    # a setuptools entrypoint:
    # - https://xon.sh/tutorial_xontrib.html#loading-xontribs
    # TODO: expose this via pyproject.toml?
    xontribs.auto_load_xontribs_from_entrypoints(verbose=True)

    # change to ~/repos/<dst_env>/ if exists
    # repo_dir: Path = Path.home()/'repos'/dst_env
    # if (
    #     cd_to_repo
    #     and repo_dir.is_dir()
    # ):
    #     rd: str = str(repo_dir)
    #     print(f'Entering repo dir: {rd}')
    #     cd @(rd)


def _pikerup() -> None:
    venv_path: str = _xenv.get('VIRTUAL_ENV')
    if venv_path:
        vox exit

    cd $HOME/repos/piker

    # won't copy into subproc..
    # $PATH.append(p'$PWD/venv/bin')

    # expect a flake
    (
        nix develop \
        --show-trace \
        --command "poetry run 'python -m xonsh ./_nix_bootstrap.xsh'"
    )

    # presume embedded venv/ hack for now..
    # nix-shell develop.nix --command 'python -m xonsh'
    if is_prolly_nix:
        # presume embedded venv/ hack for now..
        nix-shell develop.nix --command 'python -m xonsh'
    else:
        # just jump into the poetry env's xonsh
        poetry run xonsh


# XXX: i don't luv this direnv + nix interop..
# https://github.com/74th/xonsh-direnv
# xontrib load -v direnv

# add custom home/etc and .local/bin/ to path
# $PATH.extend([
#     str($HOME / Path('etc/bin')),  # personal dotfiles scripts
#     str($HOME / Path('.local/bin')),  # for rustup
# ])


def _find_mouse(
    *,
    patt: str = 'Logitech',
) -> int:
    '''
    Find the first active mouse based on naming (default logitech)
    and try to set the accelleration to max.

    '''
    names: list[str] = $(xinput --list --name-only).split('\n')
    ids: list[int] = $(xinput --list --id-only).split('\n')

    # cmd: str = '"libinput Accel Speed" 1'
    cmd: str = "libinput Accel Speed"

    for name, did in zip(names, ids):
        # print(f'name: {name}, {type(name)}')
        if (
            name
            and patt in name
        ):
            print(f'Setting `{cmd}` for device {name}@{did}')
            xinput --set-prop @(did) --type=float --format=32 @(cmd) 1


def pydoc(
    args: tuple,
    std: str,
):
    '''
    Hack around nixos pydoc override to instead use the current python
    environment's version.

    '''
    import pydoc
    sys.argv[1:] = args
    pydoc.cli()


aliases.pop('ipynb')  # faster completion to "ipy<tab>thon"
aliases.update({

    # python path hacking (mostly for nixos)
    'pyup': pyup,
    'pikerup': _pikerup,
    'pydoc': pydoc,

    # name remaps
    'grep': 'grep -n --color=auto',
    'ip': 'ip -c',
    'la': "ls -a",
    'less': 'less -R',
    'll': "ls -l",
    'lla': "ls -la",
    'ls': (
        'ls -FNh --tabsize=0 --color=auto '
        '--show-control-chars --group-directories-first'
    ),
    'vi': 'nvim',
    'vim': 'nvim',
    'he': 'hx',  # better helix key
    'hh': 'hx',  # better helix key

    # translator
    'esp': 'trans -brief en:es $1',
    'trans': 'trans -brief',

    # speach-synth
    'smbz': "espeak-ng 'meh lahh pelaas'",

    # get pub ipaddr
    'wanip': 'dig +short myip.opendns.com @resolver1.opendns.com',

    # any
    'gomuks': 'cd $HOME/repos/gomuks; ./gomuks',

    # i3-program-launching
    'wm-spawn': 'i3-msg exec "alacritty -e $1"',

    # ext mouse, bump up that speeeed
    # id 14 is from xinput, but WTF is SINO WEALTH Gaming KB?
    'fast_mouse': _find_mouse,

    # nixos helpers
    # XXX: this doesn't do a channel update..
    # 'nixup': 'nixos-rebuild --use-remote-sudo --upgrade switch',
    'nixup': (
        'sudo nixos-rebuild '
        '-I nixos-config=$HOME/repos/dotrc/dotrc/nixos/configuration.nix '
        '--upgrade switch'
    ),

})

# Coloured man page support
# using 'less' env vars (format is '\E[<brightness>;<colour>m')
# $LESS_TERMCAP_mb = "\033[01;31m"     # begin blinking
# $LESS_TERMCAP_md = "\033[01;31m"     # begin bold
# $LESS_TERMCAP_me = "\033[0m"         # end mode
# $LESS_TERMCAP_so = "\033[01;44;36m"  # begin standout-mode (bottom of screen)
# $LESS_TERMCAP_se = "\033[0m"         # end standout-mode
# $LESS_TERMCAP_us = "\033[00;36m"     # begin underline
# $LESS_TERMCAP_ue = "\033[0m"         # end underline


# def prompt():
#     """Auto update the prompt and cursor colour.
#     """
#     # import pdb; pdb.set_trace()
#     cli = builtins.__xonsh_shell__.shell.prompter.cli
#     if cli:
#         mode = cli.vi_state.input_mode
#         # print("MODE {}".format(mode))
#         if mode == vi_state.InputMode.INSERT:
#             print('\033]12;gray\007')
#             # print("INSERTING")
#             # printf '\033]12;gray\007'
#         else:
#             print('\033]12;red\007')
#             # print("NOT INSERT")
#             # printf '\033]12;red\007'

#     return '\n' + '{env_name:{}}' + ' {GREEN}>>> '


# $PROMPT = prompt
$PROMPT = '\n' + '{env_name:{}}' + ' {GREEN}>>>{DEFAULT} '
# $PROMPT = '{env_name:{}}' + ' {GREEN}>>> '

# gray cursor
# print('\033]12;gray\007')

def maybe_show_vc() -> str:
    '''
    Version control display helper that only shows the branch
    when a vcs is detected.

    '''
    branch = vc.current_branch()
    if not branch:
        return ''

    # dirty = vc.git_dirty_working_directory()
    # ops = gitstatus.get_operations()
    # $PROMPT_FIELDS

    return f'git:{branch}'


$PROMPT_FIELDS['maybe_show_vc'] = maybe_show_vc
# $PROMPT_FIELDS['branch_color'] = lambda: (
#     '{RED}' if vc.git_dirty_working_directory() else '{RESET}'
# )

$TITLE = '{current_job:{} | }{user}@{hostname}: {cwd} {maybe_show_vc}'

# $RIGHT_PROMPT = rprompt
# $BOTTOM_TOOLBAR = rprompt

# namespace bookkeeping
# _new = set()


# def ctxdiff(
#     now,
#     start,
#     remove,

# ) -> None:
#     new = now - start - remove
#     return {k: now[k] for k in new}

#     diff = ctxdiff(
#         __xonsh__.ctx,
#         __xonsh__.ctx['_startctx'],
#         {'_startctx', '__name__'},
#     )
#     _new.update(diff.keys())
#     for k, v in diff.items():
#         print('{} {}: {}'.format(type(v), k, v))


# def clear(args, stdin=None):
#     global _new
#     for k in _new:
#         __xonsh_ctx__.pop(k)
#     _new = set()


# aliases['ns'] = ctxdiff
# aliases['cns'] = clear
# _startctx  = __xonsh__.ctx.copy()


# UX related custom key bindings
@events.on_ptk_create
def custom_keybindings(
    bindings,
    **kw
):
    @bindings.add(Keys.ControlSpace)
    def fill_suggestion(event):
        '''
        Allow ctl-space to trigger auto-suggestion like
        c-e and c-f does; except easier to type quick when
        already typing commands with spaces.


        '''
        suggestion = event.current_buffer.suggestion
        if suggestion:
            event.current_buffer.insert_text(suggestion.text)
